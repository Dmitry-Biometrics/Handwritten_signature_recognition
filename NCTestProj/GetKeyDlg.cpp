// GetKeyDlg.cpp : implementation file
//

#include "stdafx.h"
#include "NCTestProj.h"
#include "GetKeyDlg.h"

// CGetKeyDlg dialog

IMPLEMENT_DYNAMIC(CGetKeyDlg, CDialog)
CGetKeyDlg::CGetKeyDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CGetKeyDlg::IDD, pParent)
{
}
// Перегруженный конструктор
CGetKeyDlg::CGetKeyDlg(int mode, bool bres, bool secret, NCKEY *learnKey, NCKEY *getKey, CWnd* pParent /*= NULL*/)
: CDialog(CGetKeyDlg::IDD, pParent)
{
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);

	bTrainMode = (mode == NCTRAIN_MODE);
	bTruePsw = bres;
	bSecret = secret;
	key		 = learnKey;
	checkKey = getKey;
	csAddInf = bTruePsw ? _T("The entered password is correct!") : _T("Wrong password entered!");
	
}

CGetKeyDlg::~CGetKeyDlg()
{
}

void CGetKeyDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CGetKeyDlg, CDialog)
	ON_BN_CLICKED(IDOK, OnClose)
	ON_BN_CLICKED(IDC_CODE_BTN, &CGetKeyDlg::OnNotationBtn)
	ON_WM_ERASEBKGND()
END_MESSAGE_MAP()

// CGetKeyDlg message handlers

// Функция, заменяющая в двоичном ключе неправильные элементы звездочкой
// Элементы полученного ключа, которые не совпадают с обучающим, 
// заменяются звёздочками
// key		   - [in]  исходный (обучающий) ключ
// checkKey	   - [in]  полученный ключ
// sCheckKey   - [out] строка с полученным двоичным ключом
// sCheckKeyZv - [out] строка с полученным двоичным ключом со звёздочками
// возвращает количество несовпавших элементов исходного и полученного ключа
int ReplaceBinKey ( NCKEY key, NCKEY checkKey, TCHAR *sCheckKey, TCHAR *sCheckKeyZv )
{
//////////////////////////////////////////////////////////////////////////
//int neverno[256] = {0};
//////////////////////////////////////////////////////////////////////////
	int errors = 0;		// количество несовпадений
	int keyArr[NEURON_COUNT], checkKeyArr[NEURON_COUNT];
	TCHAR cbinSymb[2];

	ZeroMemory( sCheckKey,	 (NEURON_COUNT+1)*sizeof(TCHAR) );
	ZeroMemory( sCheckKeyZv, (NEURON_COUNT+1)*sizeof(TCHAR) );

	// Преобразуем строковый ключ в двоичный
	BncConvertKey (key, keyArr);
	BncConvertKey (checkKey, checkKeyArr);

	// Создание строки полученного двоичного ключа со звёздочками
	for ( int i = 0; i < NEURON_COUNT; i++ ) 
	{
		_itot_s ( checkKeyArr[i], cbinSymb, 2 );
		sCheckKey[i] = cbinSymb[0];
		if ( checkKeyArr[i] != keyArr[i] ) 
		{
			cbinSymb[0] = '*';
			errors++;
//////////////////////////////////////////////////////////////////////////
//neverno[i] = 1;
//////////////////////////////////////////////////////////////////////////
		}
		sCheckKeyZv[i] = cbinSymb[0];
	}

	return errors;
}

// Выводим двоичный ключ в окне
void  CGetKeyDlg::FillEdits ( TCHAR *psw )
{
	CString str;
	for ( int iiCount = 0; iiCount < 4; iiCount++ )
	{
		if ( !bSecret ) {
			str = _T("");
			for ( int iCount = 0; iCount < 8; iCount++ ) {
				for ( int jCount = 0; jCount < 8; jCount++ ) {
					str += psw[(iCount*8+jCount)+iiCount*64];					
				}
				if (iCount<7) str += _T(" - ");
			}
		}
		else
			str = _T("********-********-********-********-********-********-********-********");
		// Вывод пароля
		SetDlgItemText(IDC_EDIT1+iiCount,str);
	}

};
BOOL CGetKeyDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Рисование иконок
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon

	m_hWhiteBrush = CreateSolidBrush(RGB(255,255,255));

	int errorCount = ReplaceBinKey(*key, *checkKey, checkKeyStr, checkKeyZvStr );
	
	// Вывод двоичного ключа
	SetDlgItemText(IDC_CODE_BTN, _T("Symbolic representation"));
	SetDlgItemText(IDC_STATIC_R, _T("Neural network generated binary password:"));
	bShowKey = TRUE;

	// Вывод двоичного ключа на экран
	if ( bTrainMode ) FillEdits(checkKeyZvStr);
	else			  FillEdits(checkKeyStr);
	
	// Вывод количества несовпавших битиков
	csErrInf.Format(_T(" The number of mismatched characters in the binary key: %d."),errorCount);

	// Преобразуем полученный ключ в строку с символьным паролём
	BncKeyToPassw ( *checkKey, pswStr, FALSE );

	return TRUE;  // return TRUE  unless you set the focus to a control
}

// Закрыть
void CGetKeyDlg::OnClose()
{
	bShowKey = TRUE; //установка в позицию вывода двоичного ключа
	OnOK();
}

// Перевод символьного пароля в двоичный ключ и обратно
void CGetKeyDlg::OnNotationBtn()
{
	if ( !bShowKey )			// вывод двоичного ключа
	{
		SetDlgItemText(IDC_CODE_BTN, _T("Symbolic representation"));
		SetDlgItemText(IDC_STATIC_R, _T("Neural network generated binary password:"));
		bShowKey = TRUE;

		// Вывод пароля двоичного ключа на экран
		if ( bTrainMode ) FillEdits(checkKeyZvStr);
		else			  FillEdits(checkKeyStr);

	}
	else					// вывод пользовательского пароля
	{
		SetDlgItemText(IDC_CODE_BTN, _T("Binary encoding"));
		SetDlgItemText(IDC_STATIC_R, _T("User password generated by the neural network:"));
		bShowKey = FALSE;
		
		if ( !bSecret ) SetDlgItemText(IDC_EDIT1, pswStr);
		else			SetDlgItemText(IDC_EDIT1, _T("********************************"));
		SetDlgItemText(IDC_EDIT2,_T(""));
		SetDlgItemText(IDC_EDIT3,_T(""));
		SetDlgItemText(IDC_EDIT4,_T(""));

	}
}

// Рисование значков "Ошибка" или "Нормально"
BOOL CGetKeyDlg::OnEraseBkgnd(CDC* pDC)
{
	CDialog::OnEraseBkgnd(pDC);

	CDC dcMem;
	CBitmap bmp;
	CRect rc;
	RECT xy;
	GetClientRect(rc);

	// Рисуем черный и белый прямоугольник
	pDC->SelectStockObject(BLACK_PEN);
	xy.left   = rc.right*18/524;
	xy.top    = rc.bottom*167/283;
	xy.right  = rc.right*505/524;
	xy.bottom = rc.bottom*210/283;
	pDC->Rectangle(xy.left, xy.top, xy.right, xy.bottom);

	pDC->SelectStockObject(WHITE_PEN);
	xy.left   = rc.right*19/524;
	xy.top    = rc.bottom*168/283;
	xy.right  = rc.right*504/524;
	xy.bottom = rc.bottom*209/283;
	pDC->Rectangle(xy.left, xy.top, xy.right, xy.bottom);

	dcMem.CreateCompatibleDC( pDC );

	switch ( bTruePsw ) {
		case TRUE:  bmp.LoadBitmap(IDB_ASTERIX); break;
		case FALSE: bmp.LoadBitmap(IDB_WARNING); break;
	}

	dcMem.SelectObject(&bmp);
	xy.left = rc.right*430/524;
	xy.top  = rc.bottom*170/283;
	pDC->BitBlt(xy.left, xy.top, rc.Width(), rc.Height(), &dcMem, 0, 0, SRCCOPY);

	// Добавляем текст
	TCHAR strBuffer[100];
	CClientDC dc(this);
	
	// Задаём шрифт выводимых сообщений
	CFont font;
	LOGFONT lf;
	memset(&lf, 0, sizeof(LOGFONT));       
	lf.lfHeight = 18;      
	lf.lfWeight = FW_NORMAL;
	_tcscpy_s(lf.lfFaceName,  _T("MS Sans Serif"));
	VERIFY(font.CreateFontIndirect(&lf));  
	dc.SelectObject(&font);
	font.DeleteObject();

	// Вывод самого текста
	_tcscpy_s(strBuffer, csAddInf);
	xy.left = rc.right*20/524;
	xy.top  = rc.bottom*171/283;
	dc.TextOut(xy.left, xy.top, strBuffer, (int)_tcslen(strBuffer));

	if ( bTrainMode ) {
		// Показываем количество несовпавших символов только если известен
		// обучающий пароль
		_tcscpy_s(strBuffer, csErrInf);
		xy.left = rc.right*20/524;
		xy.top  = rc.bottom*188/283;
		dc.TextOut(xy.left, xy.top, strBuffer, (int)_tcslen(strBuffer));
	}

	return TRUE;
}

